diff --git a/kernel/allowlist.c b/kernel/allowlist.c
index 947048f2..c80bad7e 100644
--- a/kernel/allowlist.c
+++ b/kernel/allowlist.c
@@ -10,6 +10,11 @@
 #include <linux/slab.h>
 #include <linux/types.h>
 #include <linux/version.h>
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(4, 11, 0)
+#include <linux/sched/task.h>
+#else
+#include <linux/sched.h>
+#endif
 #if LINUX_VERSION_CODE >= KERNEL_VERSION(4, 14, 0)
 #include <linux/compiler_types.h>
 #endif
@@ -18,6 +23,7 @@
 #include "klog.h" // IWYU pragma: keep
 #include "selinux/selinux.h"
 #include "allowlist.h"
+#include "kernel_compat.h"
 #include "manager.h"
 
 #define FILE_MAGIC 0x7f4b5355 // ' KSU', u32
diff --git a/kernel/file_wrapper.c b/kernel/file_wrapper.c
index 24ae979c..96f93d6e 100644
--- a/kernel/file_wrapper.c
+++ b/kernel/file_wrapper.c
@@ -249,7 +249,7 @@ static void ksu_wrapper_show_fdinfo(struct seq_file *m, struct file *f) {
 	}
 }
 
-#if LINUX_VERSION_CODE >= KERNEL_VERSION(4, 19, 0)
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(4, 5, 0)
 static ssize_t ksu_wrapper_copy_file_range(struct file *f1, loff_t off1, struct file *f2,
 		loff_t off2, size_t sz, unsigned int flags) {
 	// TODO: determine which file to use
@@ -261,49 +261,53 @@ static ssize_t ksu_wrapper_copy_file_range(struct file *f1, loff_t off1, struct
 	return -EINVAL;
 }
 
-static loff_t ksu_wrapper_remap_file_range(struct file *file_in, loff_t pos_in,
-				struct file *file_out, loff_t pos_out,
-				loff_t len, unsigned int remap_flags) {
+static ssize_t ksu_wrapper_dedupe_file_range(struct file *src_file, u64 loff,
+				u64 len, struct file *dst_file, u64 dst_loff) {
 	// TODO: determine which file to use
-	struct ksu_file_wrapper* data = file_in->private_data;
+	struct ksu_file_wrapper* data = src_file->private_data;
 	struct file* orig = data->orig;
-	if (orig->f_op->remap_file_range) {
-		return orig->f_op->remap_file_range(orig, pos_in, file_out, pos_out, len, remap_flags);
+	if (orig->f_op->dedupe_file_range) {
+		return orig->f_op->dedupe_file_range(orig, loff, len, dst_file, dst_loff);
 	}
 	return -EINVAL;
 }
-#else
+
 static int ksu_wrapper_clone_file_range(struct file *file_in, loff_t pos_in,
 				struct file *file_out, loff_t pos_out, u64 len) {
 	// TODO: determine which file to use
-	struct ksu_file_proxy* data = file_in->private_data;
+	struct ksu_file_wrapper* data = file_in->private_data;
 	struct file* orig = data->orig;
 	if (orig->f_op->clone_file_range) {
 		return orig->f_op->clone_file_range(orig, pos_in, file_out, pos_out, len);
 	}
 	return -EINVAL;
 }
+#endif
 
-static ssize_t ksu_wrapper_dedupe_file_range(struct file *src_file, u64 loff,
-				u64 len, struct file *dst_file, u64 dst_loff) {
-	// TODO: determine which file to use
-	struct ksu_file_proxy* data = src_file->private_data;
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(4, 19, 0)
+static int ksu_wrapper_fadvise(struct file *fp, loff_t off1, loff_t off2, int flags) {
+	struct ksu_file_wrapper* data = fp->private_data;
 	struct file* orig = data->orig;
-	if (orig->f_op->dedupe_file_range) {
-		return orig->f_op->dedupe_file_range(orig, loff, len, dst_file, dst_loff);
+	if (orig->f_op->fadvise) {
+		return orig->f_op->fadvise(orig, off1, off2, flags);
 	}
 	return -EINVAL;
 }
 #endif
 
-static int ksu_wrapper_fadvise(struct file *fp, loff_t off1, loff_t off2, int flags) {
-	struct ksu_file_wrapper* data = fp->private_data;
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(4, 20, 0)
+static loff_t ksu_wrapper_remap_file_range(struct file *file_in, loff_t pos_in,
+				struct file *file_out, loff_t pos_out,
+				loff_t len, unsigned int remap_flags) {
+	// TODO: determine which file to use
+	struct ksu_file_wrapper* data = file_in->private_data;
 	struct file* orig = data->orig;
-	if (orig->f_op->fadvise) {
-		return orig->f_op->fadvise(orig, off1, off2, flags);
+	if (orig->f_op->remap_file_range) {
+		return orig->f_op->remap_file_range(orig, pos_in, file_out, pos_out, len, remap_flags);
 	}
 	return -EINVAL;
 }
+#endif
 
 static int ksu_wrapper_release(struct inode *inode, struct file *filp) {
 	ksu_delete_file_wrapper(filp->private_data);
@@ -358,14 +362,17 @@ struct ksu_file_wrapper* ksu_create_file_wrapper(struct file* fp) {
 	p->ops.setlease = fp->f_op->setlease ? ksu_wrapper_setlease : NULL;
 	p->ops.fallocate = fp->f_op->fallocate ? ksu_wrapper_fallocate : NULL;
 	p->ops.show_fdinfo = fp->f_op->show_fdinfo ? ksu_wrapper_show_fdinfo : NULL;
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(4, 5, 0)
 	p->ops.copy_file_range = fp->f_op->copy_file_range ? ksu_wrapper_copy_file_range : NULL;
-#if LINUX_VERSION_CODE >= KERNEL_VERSION(4, 19, 0)
-	p->ops.remap_file_range = fp->f_op->remap_file_range ? ksu_wrapper_remap_file_range : NULL;
-	p->ops.fadvise = fp->f_op->fadvise ? ksu_wrapper_fadvise : NULL;
-#else
 	p->ops.clone_file_range = fp->f_op->clone_file_range ? ksu_wrapper_clone_file_range : NULL;
 	p->ops.dedupe_file_range = fp->f_op->dedupe_file_range ? ksu_wrapper_dedupe_file_range : NULL;
 #endif
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(4, 19, 0)
+	p->ops.fadvise = fp->f_op->fadvise ? ksu_wrapper_fadvise : NULL;
+#endif
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(4, 20, 0)
+	p->ops.remap_file_range = fp->f_op->remap_file_range ? ksu_wrapper_remap_file_range : NULL;
+#endif
 
 #if LINUX_VERSION_CODE >= KERNEL_VERSION(6, 6, 0)
 	p->ops.splice_eof = fp->f_op->splice_eof ? ksu_wrapper_splice_eof : NULL;
diff --git a/kernel/kernel_compat.h b/kernel/kernel_compat.h
index 3f5e48ff..55bb15a3 100644
--- a/kernel/kernel_compat.h
+++ b/kernel/kernel_compat.h
@@ -48,4 +48,14 @@ static long ksu_copy_from_user_retry(void *to,
 #define ksu_access_ok(addr, size)    access_ok(VERIFY_READ, addr, size)
 #endif
 
+#if LINUX_VERSION_CODE < KERNEL_VERSION(5, 8, 0)
+#define TWA_RESUME true
+#endif
+
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(5, 3, 0)
+#define ksu_force_sig(sig)      force_sig(sig);
+#else
+#define ksu_force_sig(sig)      force_sig(sig, current);
+#endif
+
 #endif
diff --git a/kernel/selinux/selinux.c b/kernel/selinux/selinux.c
index 57c2be1b..5de63e9e 100644
--- a/kernel/selinux/selinux.c
+++ b/kernel/selinux/selinux.c
@@ -116,7 +116,11 @@ bool is_task_ksu_domain(const struct cred* cred)
     if (!cred) {
         return false;
     }
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(5,1,0)
     const struct task_security_struct *tsec = selinux_cred(cred);
+#else
+    const struct task_security_struct *tsec = cred->security;
+#endif
     if (!tsec) {
         return false;
     }
@@ -140,7 +144,11 @@ bool is_zygote(const struct cred* cred)
     if (!cred) {
         return false;
     }
-    const struct task_security_struct * tsec = selinux_cred(cred);
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(5,1,0)
+    const struct task_security_struct *tsec = selinux_cred(cred);
+#else
+    const struct task_security_struct *tsec = cred->security;
+#endif
     if (!tsec) {
         return false;
     }
diff --git a/kernel/supercalls.c b/kernel/supercalls.c
index 897c7634..73dd09ae 100644
--- a/kernel/supercalls.c
+++ b/kernel/supercalls.c
@@ -382,10 +382,17 @@ static int do_get_wrapper_fd(void __user *arg) {
 
 #if LINUX_VERSION_CODE >= KERNEL_VERSION(6, 12, 0)
 #define getfd_secure anon_inode_create_getfd
-#else
+#elif LINUX_VERSION_CODE >= KERNEL_VERSION(5, 12, 0)
 #define getfd_secure anon_inode_getfd_secure
+#else
+// figure out better way later
+#define getfd_secure anon_inode_getfd
 #endif
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(5, 12, 0)
     ret = getfd_secure("[ksu_fdwrapper]", &data->ops, data, f->f_flags, NULL);
+#else
+    ret = getfd_secure("[ksu_fdwrapper]", &data->ops, data, f->f_flags);
+#endif
     if (ret < 0) {
         pr_err("ksu_fdwrapper: getfd failed: %d\n", ret);
         goto put_wrapper_data;
@@ -393,7 +400,12 @@ static int do_get_wrapper_fd(void __user *arg) {
     struct file* pf = fget(ret);
 
     struct inode* wrapper_inode = file_inode(pf);
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(5, 1, 0) || defined(KSU_OPTIONAL_SELINUX_INODE)
     struct inode_security_struct *sec = selinux_inode(wrapper_inode);
+#else
+    struct inode_security_struct *sec =
+        (struct inode_security_struct *)wrapper_inode->i_security;
+#endif
     if (sec) {
         sec->sid = ksu_file_sid;
     }
